var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// Internal Imports
import { Component } from "../component";
import { AxisPositions, ScaleTypes, Roles } from "../../interfaces";
import { Tools } from "../../tools";
import { DOMUtils } from "../../services";
import * as Configuration from "../../configuration";
// D3 Imports
import { axisBottom, axisLeft, axisRight, axisTop } from "d3-axis";
import { timeFormatDefaultLocale } from "d3-time-format";
var Axis = /** @class */ (function (_super) {
    __extends(Axis, _super);
    function Axis(model, services, configs) {
        var _this = _super.call(this, model, services, configs) || this;
        _this.type = "axes";
        if (configs) {
            _this.configs = configs;
        }
        _this.margins = _this.configs.margins;
        return _this;
    }
    Axis.prototype.render = function (animate) {
        if (animate === void 0) { animate = true; }
        var axisPosition = this.configs.position;
        var options = this.model.getOptions();
        var axisOptions = Tools.getProperty(options, "axes", axisPosition);
        var svg = this.getContainerSVG();
        var _a = DOMUtils.getSVGElementSize(this.parent, { useAttrs: true }), width = _a.width, height = _a.height;
        var startPosition, endPosition;
        if (axisPosition === AxisPositions.BOTTOM || axisPosition === AxisPositions.TOP) {
            startPosition = this.configs.axes[AxisPositions.LEFT] ? this.margins.left : 0;
            endPosition = this.configs.axes[AxisPositions.RIGHT] ? width - this.margins.right : width;
        }
        else {
            startPosition = height - this.margins.bottom;
            endPosition = this.margins.top;
        }
        // Grab the scale off of the Scales service
        var scale = this.services.cartesianScales.getScaleByPosition(axisPosition);
        if (this.scaleType === ScaleTypes.LABELS) {
            scale.rangeRound([startPosition, endPosition]);
        }
        else {
            scale.range([startPosition, endPosition]);
        }
        // Identify the corresponding d3 axis function
        var axisFunction;
        switch (axisPosition) {
            case AxisPositions.LEFT:
                axisFunction = axisLeft;
                break;
            case AxisPositions.BOTTOM:
                axisFunction = axisBottom;
                break;
            case AxisPositions.RIGHT:
                axisFunction = axisRight;
                break;
            case AxisPositions.TOP:
                axisFunction = axisTop;
                break;
        }
        // Set the date/time locale
        if (this.scaleType === ScaleTypes.TIME) {
            var timeLocale = Tools.getProperty(options, "locale", "time");
            if (timeLocale) {
                timeFormatDefaultLocale(timeLocale);
            }
        }
        // Initialize axis object
        var axis = axisFunction(scale)
            .tickSizeOuter(0)
            .tickFormat(Tools.getProperty(axisOptions, "ticks", "formatter"));
        if (scale.ticks) {
            var numberOfTicks = Tools.getProperty(axisOptions, "ticks", "number") || Configuration.axis.ticks.number;
            axis.ticks(numberOfTicks);
            if (this.scaleType === ScaleTypes.TIME) {
                var tickValues = scale.ticks(numberOfTicks).concat(scale.domain())
                    .map(function (date) { return +date; }).sort();
                tickValues = Tools.removeArrayDuplicates(tickValues);
                // Remove labels on the edges
                // If there are more than 2 labels to show
                if (Tools.getProperty(options, "timeScale", "addSpaceOnEdges") && tickValues.length > 2) {
                    tickValues.splice(tickValues.length - 1, 1);
                    tickValues.splice(0, 1);
                }
                axis.tickValues(tickValues);
            }
        }
        // Add axis into the parent
        var container = DOMUtils.appendOrSelect(svg, "g.axis." + axisPosition);
        var axisRefExists = !container.select("g.ticks").empty();
        var axisRef = DOMUtils.appendOrSelect(container, "g.ticks");
        if (!axisRefExists) {
            axisRef.attr("role", Roles.GRAPHICS_OBJECT + " " + Roles.GROUP);
        }
        // We draw the invisible axis because of the async nature of d3 transitions
        // To be able to tell the final width & height of the axis when initiaing the transition
        // The invisible axis is updated instantly and without a transition
        var invisibleAxisRef = DOMUtils.appendOrSelect(container, "g.ticks.invisible")
            .style("opacity", "0")
            .attr("aria-hidden", true);
        // Position and transition the axis
        switch (axisPosition) {
            case AxisPositions.LEFT:
                axisRef.attr("transform", "translate(" + this.margins.left + ", 0)");
                break;
            case AxisPositions.BOTTOM:
                axisRef.attr("transform", "translate(0, " + (height - this.margins.bottom) + ")");
                break;
            case AxisPositions.RIGHT:
                axisRef.attr("transform", "translate(" + (width - this.margins.right) + ", 0)");
                break;
            case AxisPositions.TOP:
                axisRef.attr("transform", "translate(0, " + this.margins.top + ")");
                break;
        }
        // Position the axis title
        if (axisOptions.title) {
            var axisTitleRef = DOMUtils.appendOrSelect(container, "text.axis-title")
                .text(axisOptions.title);
            switch (axisPosition) {
                case AxisPositions.LEFT:
                    axisTitleRef.attr("transform", "rotate(-90)")
                        .attr("y", 0)
                        .attr("x", -(scale.range()[0] / 2))
                        .attr("dy", "1em")
                        .style("text-anchor", "middle");
                    break;
                case AxisPositions.BOTTOM:
                    axisTitleRef.attr("transform", "translate(" + (this.margins.left / 2 + scale.range()[1] / 2) + ", " + height + ")")
                        .style("text-anchor", "middle");
                    break;
                case AxisPositions.RIGHT:
                    axisTitleRef.attr("transform", "rotate(90)")
                        .attr("y", -width)
                        .attr("x", scale.range()[0] / 2)
                        .attr("dy", "1em")
                        .style("text-anchor", "middle");
                    break;
                case AxisPositions.TOP:
                    var titleHeight = DOMUtils.getSVGElementSize(axisTitleRef, { useBBox: true }).height;
                    axisTitleRef.attr("transform", "translate(" + (this.margins.left / 2 + scale.range()[1] / 2) + ", " + titleHeight / 2 + ")")
                        .style("text-anchor", "middle");
                    break;
            }
        }
        // Apply new axis to the axis element
        if (!animate || !axisRefExists) {
            axisRef = axisRef.call(axis);
        }
        else {
            axisRef = axisRef.transition(this.services.transitions.getTransition("axis-update"))
                .call(axis);
        }
        invisibleAxisRef.call(axis);
        if (axisPosition === AxisPositions.BOTTOM || axisPosition === AxisPositions.TOP) {
            var rotateTicks = false;
            // If we're dealing with a discrete scale type
            // We're able to grab the spacing between the ticks
            if (scale.step) {
                var textNodes = invisibleAxisRef.selectAll("g.tick text").nodes();
                // If any ticks are any larger than the scale step size
                rotateTicks = textNodes.some(function (textNode) { return DOMUtils.getSVGElementSize(textNode, { useBBox: true }).width >= scale.step(); });
            }
            else {
                // When dealing with a continuous scale
                // We need to calculate an estimated size of the ticks
                var minTickSize = Tools.getProperty(axisOptions, "ticks", "rotateIfSmallerThan") || Configuration.axis.ticks.rotateIfSmallerThan;
                var estimatedTickSize = width / scale.ticks().length / 2;
                rotateTicks = estimatedTickSize < minTickSize;
            }
            if (rotateTicks) {
                container.selectAll("g.ticks g.tick text")
                    .attr("transform", "rotate(45)")
                    .style("text-anchor", axisPosition === AxisPositions.TOP ? "end" : "start");
            }
            else {
                container.selectAll("g.ticks g.tick text")
                    .attr("transform", null)
                    .style("text-anchor", null);
            }
        }
    };
    Axis.prototype.getInvisibleAxisRef = function () {
        var axisPosition = this.configs.position;
        return this.getContainerSVG()
            .select("g.axis." + axisPosition + " g.ticks.invisible");
    };
    Axis.prototype.getTitleRef = function () {
        var axisPosition = this.configs.position;
        return this.getContainerSVG()
            .select("g.axis." + axisPosition + " text.axis-title");
    };
    return Axis;
}(Component));
export { Axis };
//# sourceMappingURL=../../../../src/components/axes/axis.js.map